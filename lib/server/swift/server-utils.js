// Generated by CoffeeScript 1.6.3
(function() {
  var aclUtils, checkAcl, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('lodash');

  aclUtils = require('../../acl-utils');

  checkAcl = function(getContainer, authAccount, method, referrer) {
    return getContainer().then(function(ci) {
      var acl, groups, refs, _ref, _ref1, _ref2;
      if (ci != null) {
        acl = ((_ref = ci.acl) != null ? _ref.read : void 0) && (method === 'GET' || method === 'HEAD') ? ci.acl.read : ((_ref1 = ci.acl) != null ? _ref1.write : void 0) && (method === 'PUT' || method === 'POST' || method === 'DELETE') ? ci.acl.write : void 0;
        if (acl) {
          _ref2 = aclUtils.parseAcl(acl), refs = _ref2[0], groups = _ref2[1];
          return __indexOf.call(groups, authAccount) >= 0 || aclUtils.referrerAllowed(referrer, refs);
        }
      }
    });
  };

  exports.authorize = function(req, res, authAccount, getContainer) {
    return authAccount.then(function(authAccount) {
      var otherwise;
      if (authAccount && req.account === authAccount) {
        return true;
      }
      otherwise = function() {
        if (!authAccount) {
          throw res.send(401);
        }
        throw res.send(403);
      };
      if (req.container) {
        return checkAcl(getContainer, authAccount, req.method, req.headers['referrer']).then(function(allowed) {
          if (!allowed) {
            return otherwise();
          }
        });
      }
      return otherwise();
    });
  };

  exports.extractMetadata = function(headers, type) {
    var md, regex, removeRegex;
    if (type == null) {
      type = 'object';
    }
    regex = new RegExp("x-" + type + "-meta-");
    removeRegex = new RegExp("x-remove-" + type + "-meta-");
    md = _(headers).pairs().filter(function(_arg) {
      var k, v;
      k = _arg[0], v = _arg[1];
      return regex.test(k);
    }).map(function(_arg) {
      var k, v;
      k = _arg[0], v = _arg[1];
      return [k.replace(regex, ''), v];
    }).object().value();
    _(headers).keys().filter(function(k) {
      return removeRegex.test(k);
    }).map(function(k) {
      return k.replace(removeRegex, '');
    }).forEach(function(k) {
      return md[k] = null;
    });
    return md;
  };

  exports.attachMetadata = function(metadata, res, type) {
    if (type == null) {
      type = 'object';
    }
    return _(metadata).pairs().forEach(function(_arg) {
      var k, v;
      k = _arg[0], v = _arg[1];
      if (v) {
        return res.set("x-" + type + "-meta-" + k, v);
      }
    });
  };

  exports.extractAcl = function(headers) {
    var acl, read, write;
    acl = {};
    read = headers['x-container-read'];
    if (read) {
      acl.read = aclUtils.cleanAcl('read', read);
    }
    write = headers['x-container-write'];
    if (write) {
      acl.write = aclUtils.cleanAcl('write', write);
    }
    return acl;
  };

  exports.attachAcl = function(acl, res) {
    if (acl != null ? acl.read : void 0) {
      res.set('x-container-read', acl.read);
    }
    if (acl != null ? acl.write : void 0) {
      return res.set('x-container-write', acl.write);
    }
  };

  exports.formatObjects = function(objects, prefix, delimiter, path, marker) {
    var objs, objsMeta, pathMode, pfx, prefixRegex;
    objs = _.keys(objects);
    pathMode = false;
    if (path != null) {
      if (path.slice(-1) !== '/' && path !== '') {
        path = path + '/';
      }
      prefix = path;
      delimiter = '/';
      pathMode = true;
    }
    if (prefix) {
      prefixRegex = new RegExp('^' + prefix);
      objs = _.filter(objs, function(obj) {
        return prefixRegex.test(obj);
      });
    }
    if (delimiter) {
      pfx = prefix || '';
      objs = _.map(objs, function(obj) {
        var parts;
        obj = obj.substring(pfx.length);
        parts = obj.split(delimiter);
        if (parts.length === 1) {
          return pfx + parts[0];
        } else {
          return pfx + parts[0] + delimiter;
        }
      });
      objs = _.uniq(objs);
    }
    objsMeta = objs.map(function(objName) {
      var obj;
      obj = objects[objName];
      if (obj != null) {
        return {
          bytes: obj.contentLength,
          content_type: obj.contentType,
          hash: obj.hash,
          last_modified: obj.lastModified.toISOString().slice(0, -1),
          name: objName
        };
      } else {
        return {
          subdir: objName
        };
      }
    });
    if (pathMode) {
      objsMeta = objsMeta.filter(function(x) {
        return x.subdir == null;
      });
    }
    if (marker != null) {
      objsMeta = [];
    }
    return objsMeta;
  };

  exports.parseCopyPath = function(path) {
    var parts, regex;
    regex = new RegExp('/?([^/]+)/(.*)');
    parts = path.match(regex);
    if (!parts) {
      return;
    }
    return {
      container: parts[1],
      object: parts[2]
    };
  };

  exports.reqIsJson = function(req) {
    var accept, contentType, format;
    accept = req.get('accept');
    contentType = req.get('content-type');
    format = req.param('format');
    if (accept === 'application/json') {
      return true;
    }
    if (accept === 'text/json') {
      return true;
    }
    if ((contentType != null) && contentType.split(';')[0] === 'application/json') {
      return true;
    }
    if ((contentType != null) && contentType.split(';')[0] === 'text/json') {
      return true;
    }
    if (format === 'json') {
      return true;
    }
    return false;
  };

}).call(this);
